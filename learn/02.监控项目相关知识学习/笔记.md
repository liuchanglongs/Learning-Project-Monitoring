# 1. 前端监控什么

- 异常监控、性能监控（核心 ）
- 用户行为监控/用户行为埋点：又分为无痕埋点、可视化埋点、手工埋点 ---> 对应的 sdk 需要封装

# 2. 了解指标

## 浏览器

    - Web Vitals：是谷歌针对网页加载速度和体验所提出的一套指标，这套指标用于测试网页的加载速度及用户体验等等；
        地址：https://web.developers.google.cn/articles/fcp?hl=zh-cn
    - 浏览器性能检测API:
        https://developer.mozilla.org/zh-CN/docs/Web/API/Performance_API
        https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver

## node

    node 性能采集：https://nodejs.org/docs/latest/api/perf_hooks.html

# 3. 指标体系设计 ​

    指标体系设计，是监控平台设计中的重要一环，我们提到的指标，包含:性能指标​、异常指标、埋点数据​、自定义​实现

## 性能指标采集 ​

    性能指标，可以充分衡量并分析应用各项性能指数，从而不断优化改良应用。
    异常指标可以在应用代码发生报错时，上报错误，开发人员只需要查看监控平台即可清晰看到异常详情。
    埋点数据用于采集用户事件操作，从而分析用户使用偏好。自定义指标可以提供给开发者拓展采集指标数据。

1. 性能指标是衡量用户体验的重要指标。常见的 Web 性能指标包括：​
   CLS (Cumulative Layout Shift)：累积布局偏移，衡量页面布局的稳定性。​
   LCP (Largest Contentful Paint)：最大内容绘制时间，衡量页面主要内容的加载速度。​
   TTFB (Time to First Byte)：首字节时间，衡量服务器的响应速度。​
   INP (Interaction to Next Paint)：交互到下一次绘制的时间，衡量页面响应交互的速度。​
   FP（First Paint）：首次向屏幕绘制内容的时间 ​
   FCP（First Contentful Paint）：浏览器首次绘制出内容元素的时间 ​
   FMP（First Meaningful Paint）：首次绘制用户关注内容的时间 ​`需要自己实现`
   ​
2. 实现原理：​
   我们可以使用 PerformanceObserver 和` Web Vitals API 三方库` 来监控和采集上述性能指标。每当指标更新时，通过回调机制将数据捕获并上传到后端。​

   ​PerformanceObserver 可以用于监控不同类型的性能指标，通过回调函数处理捕获的数据。SDK 中可以针对每个性能指标设置不同的观察者，收集页面加载和交互性能数据。
   ​

3. 代码实现: ​[text](src/utils/performanceIndicators.ts)

## 异常采集 ​

&emsp;&emsp;异常采集是 SDK 最重要的功能之一，能够帮助开发者监控到前端应用中未处理的错误和异常。我们可以通过 window.onerror 和 window.onunhandledrejection 捕获全局的 JavaScript 错误和未处理的 Promise 拒绝。​
​

1. 实现原理：​

- 全局错误捕获：通过监听 window.onerror 事件，捕获到所有未捕获的 JavaScript 错误。​
- 未处理的 Promise 捕获：通过监听 window.onunhandledrejection，捕获未处理的 Promise 异常。
- error：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error​
- Promise 异常全局捕获：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/unhandledrejection_event​
- 全局异常捕获：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/error_event

2. 代码实现:[text](src/utils/ErrorCapture.ts)

## 事件采集(自定义、埋点)

&emsp;&emsp;事件采集是用户操作行为监控的核心，包括对 DOM 事件、XHR 请求、Fetch 请求等的采集。Sentry 通过对原生方法的代理，捕获用户操作并记录在系统中。​
​

- 事件类型：​DOM 事件：例如点击、键盘输入等用户操作。​
- XHR 和 Fetch 请求：通过`代理原生`的 XMLHttpRequest 和 fetch，捕获每个网络请求的详情，包括 URL、响应时间、状态码等。​
- History 和 Navigation API 事件：捕获页面导航行为，如前进、后退操作等。​

1. 实现原理：​
   &emsp;&emsp;我们可以通过重写 addEventListener 方法，来捕获用户在页面上进行的点击、键盘输入等操作。同时，通过代理 XMLHttpRequest 和 fetch 来拦截网络请求，并记录相关信息。​
   ​
   示例实现代码：​[text](src/utils/EventCollection.ts)
   ​

## Node 性能采集【拓展】​

&emsp;&emsp;在 Node.js 中，我们可以使用 node:perf_hooks 模块来实现与 W3C Web Performance API 相关的功能。这些功能通常用于监控代码性能，帮助开发者理解代码执行的效率。Node.js 支持以下几个 Web 性能 API：​
​

- High Resolution Time: 提供高精度的时间测量，可以精确到微秒级别。​
- Performance Timeline: 允许记录和观察代码运行的性能事件。​
- User Timing: 允许开发者为特定的代码片段标记时间，以便计算执行时长。​
- Resource Timing: 用于收集和记录应用程序中加载资源的性能数据。​
  ​
  下面是如何通过 node:perf_hooks 进行性能测量的示例：​ 使用 PerformanceObserver 和性能测量

```js
const { PerformanceObserver, performance } = require('node:perf_hooks')

// 创建 PerformanceObserver 实例，用于监听性能指标
const obs = new PerformanceObserver((items) => {
  // 输出性能测量的持续时间
  console.log(items.getEntries()[0].duration)
})

// 开始观察 'measure' 类型的性能事件
obs.observe({ type: 'measure' })

// 执行一次测量，标记从开始到当前的时间
performance.measure('Start to Now')

// 标记 A 点
performance.mark('A')

// 执行一些耗时的任务
function doSomeLongRunningProcess(callback) {
  setTimeout(callback, 1000) // 模拟一个耗时的异步操作（修正拼写错误）
}

// 在任务执行完毕后进行性能测量
doSomeLongRunningProcess(() => {
  // 从标记 A 到当前时间的性能测量
  performance.measure('A to Now', 'A')
  // 标记 B 点
  performance.mark('B')
  // 测量从标记 A 到标记 B 之间的时间
  performance.measure('A to B', 'A', 'B')
})
```

代码说明：​

- PerformanceObserver: 通过 PerformanceObserver 我们可以监听性能事件，例如 measure 类型的事件。obs.observe({ type: 'measure' }) 开始监听测量事件，一旦有性能测量完成，回调函数会被触发，并输出测量结果。​
- performance.mark(): 用于标记代码执行中的某个时刻，例如 performance.mark('A') 用来记录当前的时间点，我们可以用它来作为基准点进行后续的测量。​
- performance.measure(): 用于测量两个标记点之间的时间，或者从某个标记点到当前时间的持续时间。例如 performance.measure('A to B', 'A', 'B') 可以测量从标记 A 到标记 B 的时间差。​
- doSomeLongRunningProcess: 模拟一个耗时的任务（如网络请求或复杂计算），任务执行完毕后我们可以测量任务的执行时间。

## 总结 ​

​
&emsp;&emsp;通过上述方式，我们可以构建一个类似 Sentry 的 SDK，覆盖性能指标、事件和异常的采集。具体实现要点包括：​

    使用 PerformanceObserver 和 Web Vitals API 来采集性能数据。​
    代理 addEventListener、XMLHttpRequest 和 fetch 来捕获用户操作和网络请求。​
    通过 window.onerror 和 window.onunhandledrejection 捕获全局异常和未处理的 Promise 拒绝。​

​
&emsp;&emsp;这一套方案可以帮助开发者实时监控前端应用的运行情况，并提供有价值的性能、事件和错误数据，用于优化应用和提升用户体验。
